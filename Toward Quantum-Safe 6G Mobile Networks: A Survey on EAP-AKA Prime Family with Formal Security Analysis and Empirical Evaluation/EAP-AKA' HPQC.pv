   set ignoreTypes = false.

   type pubKey.
   type secKey.
   type key.
   type seq.

   table ueDB(bitstring, key, seq).

   free sch:   channel [private].
   free usch:  channel.
   free counter: seq.

   const AMF: bitstring.
   const SNname: bitstring.

   free rID_test: bitstring[private].
   query attacker(rID_test).

   free test1: bitstring[private].
   free test2: bitstring[private].
   free test3: bitstring[private].   
   query attacker(test1).

   fun fP_k1(key): key.
   fun fP_k2(key): key.
   fun sha256(bitstring): bitstring.
   fun calc_sqn(seq, pubKey, bitstring): seq.
   fun pk(secKey): pubKey.
   fun sk(pubKey): secKey [private].
   fun hmac(key, bitstring): bitstring.
   fun hash(bitstring): bitstring.

   fun f1(bitstring, bitstring, bitstring): bitstring. (* MAC *)
   fun f2(bitstring): bitstring. (* XRES *)
   fun f3(bitstring): bitstring. (* CK *)
   fun f4(bitstring): bitstring. (* IK *)
   fun f5(bitstring): bitstring. (* AK *)

   fun fP_pk1(pubKey): pubKey.
   fun fP_pk2(pubKey): pubKey.
   fun k2b(key):           bitstring[data, typeConverter].
   fun b2k(bitstring):     key[data, typeConverter].
   fun k2sk(key):          secKey[data, typeConverter].
   fun pk2b(pubKey):       bitstring[data, typeConverter].
   fun n2b(nat):           bitstring[data, typeConverter].
   fun seq2b(seq):         bitstring[data, typeConverter].
   fun b2seq(bitstring):   seq[data, typeConverter].
   fun sk2b(secKey):       bitstring[data, typeConverter].

   fun ML_KEM_768_keygen_32(bitstring) : secKey.
   fun ML_KEM_768_keygen_EC(bitstring) : secKey.

   (* PQC-KEM *)
   fun penc(bitstring, pubKey):bitstring.
   reduc forall dk:pubKey, k:bitstring;
   pdec(penc(k, dk),sk(dk)) = k.

   letfun kem_enc(ek: pubKey) =
         new ss: bitstring;
         (ss, penc(ss, ek)).
         
   letfun kem_dec(dk: secKey, ct: bitstring) =
         let k = pdec(ct, dk) in
         (k).

   (* Encryption/Decryption *)
   fun senc(bitstring, key): bitstring.
   reduc forall m: bitstring, n: key;
   sdec(senc(m, n), n) = m.

   (* XOR *)
   fun xor(bitstring, bitstring): bitstring.
   equation forall m: bitstring, n: bitstring;
   xor(xor(m, n), n) = m.

   (* DH key-exchange *)
   fun DHkey(secKey, pubKey): key.
   equation forall sk1: secKey, sk2: secKey;
   DHkey(sk2, pk(sk1)) = DHkey(sk1, pk(sk2)).

   (* a Key Derivation function *)
   fun KDF(bitstring): key.
   fun KDF_encr(key): key.
   fun KDF_re(bitstring): key.
   fun KDF_aut(key): key.

   (* Event *)
   event beginUE_HN_SUPI(bitstring, pubKey, pubKey).        (*SUPI, ue_pubkey, hn_pubkey*)
   event endUE_HN_SUPI(bitstring, pubKey, pubKey).          (*SUPI, ue_pubkey, hn_pubkey*)
   event beginHN_UE_MAC(bitstring, key, bitstring, seq).    (*SUPI, K, RAND, SQN*)
   event endUE_HN_MAC(bitstring, key, bitstring, seq).      (*SUPI, K, RAND, SQN*)
   event beginUE_RES(bitstring, key, bitstring, seq).       (*SUPI, K, RAND, SQN*)
   event middleSN_RES(bitstring, bitstring).                (*RES'*)
   event middleHN_RES(bitstring, key, bitstring, seq).      (*SUPI, K, RAND, SQN*)
   event endSN_ANCHOR_KEY(bitstring, key).                  (*SUPI, KSEAF*)
   event beginUE_HN_ERP(bitstring, key, seq).        (*SUPI, ue_pubkey, hn_pubkey*)
   event endHN_UE_ERP(bitstring, key, seq).          (*SUPI, ue_pubkey, hn_pubkey*)
   event MACFailure().
   event SYNCFailure().
   
   (* 기밀성 *)
   free supi_test:   bitstring [private].
   free kseaf_test:  bitstring [private].
   free kausf_test:  bitstring [private].
   free rMSK_test:  bitstring [private].
   query attacker(supi_test).
   query attacker(kseaf_test).
   query attacker(kausf_test).
   query attacker(rMSK_test).
  
   (* authentication *)
   query supi: bitstring, uepk: pubKey, hnpk: pubKey; (* UE-HN SUPI 검증 *)
   inj-event(endUE_HN_SUPI(supi, uepk, hnpk))
   ==> inj-event(beginUE_HN_SUPI(supi, uepk, hnpk)).
   query supi: bitstring, k: key, rand: bitstring, sqn: seq; (* UE-HN MAC 검증 *)
   inj-event(endUE_HN_MAC(supi, k, rand, sqn))
   ==> inj-event(beginHN_UE_MAC(supi, k, rand, sqn)).
   query supi: bitstring, k: key, rand: bitstring, sqn: seq, res': bitstring, kseaf: key; (* UE-SN RES 검증 *)
   inj-event(endSN_ANCHOR_KEY(supi, kseaf))
   ==> (inj-event(middleHN_RES(supi, k, rand, sqn)) ==> 
         (inj-event(middleSN_RES(res', rand)) ==> 
            inj-event(beginUE_RES(supi, k, rand, sqn))
         )
       ).


   letfun XWingKeyEnc(pk1: pubKey, pk2: pubKey) =
      (
         new sk: secKey;
         let (ss1: bitstring, c1: bitstring) = kem_enc(pk1) in
         let c2 = pk(sk) in
         let ss2 = DHkey(sk, pk2) in
         let ss = hash((ss1, ss2, c2, pk2)) in
         (ss, c1, c2)
      ).

   letfun XWingKeyDec(c1: bitstring, c2: pubKey, skue: secKey) =
      let c0_hn = pk(skue) in
      let pkue1 = fP_pk1(c0_hn) in
      let pkue2 = fP_pk2(c0_hn) in

      let ss1 = kem_dec(sk(pkue1), c1) in
      let ss2 = DHkey(sk(pkue2), c2) in

      let ss = hash((ss1, ss2, c2, pkue2)) in
         (ss).

   letfun calc_ue_suci(skue: secKey, supi: bitstring, pkhn: pubKey) =
      let c0_ret  = pk(skue) in (* C0 *)
      let mk      = KDF(k2b(DHkey(skue, pkhn))) in
      let k1      = fP_k1(mk) in
      let c1_ret  = senc(supi, k1) in (* C1 *)
      let k2      = fP_k2(mk) in 
      let c2_ret  = hmac(k2, c1_ret) in (* C2 *) 
         (c0_ret, c1_ret, c2_ret).

   letfun get_hn_keys4supi(skhn: secKey, c0: pubKey, c1: bitstring, c2: bitstring) =
      let pkhn    = pk(skhn)    in
      let mk      = KDF(k2b(DHkey(skhn, c0))) in
      let k1      = fP_k1(mk) in
      let k2      = fP_k2(mk) in 
          (k1, k2).

   letfun calc_hn_supi(skhn: secKey, c0: pubKey, c1: bitstring, c2: bitstring) =
      let pkhn    = pk(skhn)    in
      let mk      = KDF(k2b(DHkey(skhn, c0))) in
      let k1      = fP_k1(mk) in
      let k2      = fP_k2(mk) in
      if c2  = hmac(k2, c1) then (* suci mac verification*)
      (
         let supi_ret = sdec(c1, k1) in (* gettting SUPI *)
            (supi_ret)
      ).

   letfun calc_hn_mac(rand: bitstring, k: key, sqn: seq, amf: bitstring) =       
      let rand_    = xor(rand, k2b(k)) in (* xor(rand,k) 치환 *)
      let ak_ret   = f5(rand_) in
      let conc_ret = xor(seq2b(sqn), ak_ret) in(* AUTN = CONC,AMF,hMAC *)
      let mac_ret  = f1(rand_, seq2b(sqn), amf) in
         (conc_ret, ak_ret, mac_ret).

   letfun calc_ue_mac(rand: bitstring, k: key, conc: bitstring, amf: bitstring) =       
      let rand__  = xor(rand, k2b(k)) in (* xor(RAND,K) 치환 *)
      let ak_ret  = f5(rand__) in
      let sqn_ret = xor(conc, ak_ret) in
      let mac_ret = f1(rand__, sqn_ret, amf) in
         (mac_ret, sqn_ret, ak_ret).

   letfun calc_AV(mac:bitstring, amf: bitstring, rand: bitstring, k: key, sqn: seq, ak: bitstring) =       
      let rand__     = xor(rand, k2b(k)) in (* xor(RAND,K) 치환 *)
      let RES        = f2(rand__) in    
      let CK         = f3(rand__) in
      let IK         = f4(rand__) in
      let CK'        = k2b(KDF((CK,IK, SNname, xor(seq2b(sqn), ak)))) in
      let IK'        = k2b(KDF((CK,IK, SNname, xor(seq2b(sqn), ak)))) in
      let MK         = KDF((CK,IK, SNname, xor(seq2b(sqn), ak))) in
      let kENCR      = KDF_encr(MK) in
      let kAUT       = KDF_aut(MK) in
      let AT_MAC_ret = hmac(kAUT, (rand, sqn, amf, mac, RES)) in
      let RES'_ret   = k2b(KDF((CK', IK', SNname, rand, RES))) in                               
      let HXRES'_ret = sha256((rand, RES'_ret)) in
         (RES, kENCR, kAUT, RES'_ret, HXRES'_ret, IK', CK', AT_MAC_ret).

   (* The process at the UE *)
   let UE(ueSUPI: bitstring, ueK: key, sqn: seq, pkHN: pubKey)=  
      new skUE: secKey;
      let (c0: pubKey, c1: bitstring, c2: bitstring) = calc_ue_suci(skUE, ueSUPI, pkHN) in
      ( 
         event beginUE_HN_SUPI(ueSUPI, c0, pkHN);
         out(usch, (c0, c1, c2)); (* SUCI<-(C0,C1,C2) *) (*1*)
         in(usch, (RAND_ue: bitstring, CONC_ue: bitstring, AMF_ue: bitstring, MAC_ue: bitstring, c1: bitstring, c2:pubKey, hAT_MAC: bitstring, hAT_ENCR: bitstring));(*4*)      
         let (uMAC: bitstring, hnSQN: bitstring, uAK: bitstring) = calc_ue_mac(RAND_ue, ueK, CONC_ue, AMF_ue) in
         (
            if uMAC = MAC_ue then (*MAC verification*)
            (
               let ueSQN = calc_sqn(sqn, c0, RAND_ue) in
               if hnSQN = seq2b(ueSQN) then
               (
                  event endUE_HN_MAC(ueSUPI, ueK, RAND_ue, ueSQN);
                  event beginUE_RES(ueSUPI, ueK, RAND_ue, ueSQN);
                  let (RES: bitstring, kENCR: key, kAUT: key, RES': bitstring, HXRES': bitstring, IK': bitstring, CK': bitstring, uAT_MAC: bitstring) = calc_AV(MAC_ue, AMF_ue, RAND_ue, ueK, ueSQN, uAK) in      
                  if hAT_MAC = hmac(kAUT, (RAND_ue, ueSQN, AMF_ue, MAC_ue, RES)) then (*AT_MAC verification*)
                  (
                    let rID = xor(hAT_ENCR, k2b(kENCR)) in
                    let ss = XWingKeyDec(c1, c2, skUE) in
                    let MK_ECDHE  = k2b(KDF((ss))) in
                    let kRE = KDF_re((MK_ECDHE)) in
                    let kAUSF     = KDF((MK_ECDHE)) in
                    let kSEAF     = KDF((kAUSF, SNname)) in
                    out(usch, (RES', uAT_MAC)); (* 5 *)
                    out(usch, (rID, SNname)); (* 1- ERP *)
                    in(usch, AT_nonce: bitstring);(* 4- ERP *) 
                    let nonce_s = xor(AT_nonce, uAK) in
                    let rMSK = KDF((kRE, rID, counter, AT_nonce)) in
                    out(usch, (senc(kseaf_test, kSEAF), senc(kausf_test, kAUSF),senc(supi_test, b2k(ueSUPI)), senc(rMSK_test, rMSK), senc(rID_test, b2k(ueSUPI))))
                  )
               )
               else
                  event SYNCFailure()
            )
            else 
               event MACFailure()
         )
      ). 
    
   (* The process at the SN -------------------------------------------------------------- *)
   let SN(SNname: bitstring)=
      new dsch: channel;
      out(sch, (dsch));
      in (usch, (c0_sn: pubKey, c1_sn: bitstring, c2_sn: bitstring));(* 1 *)
      out(dsch, (c0_sn, c1_sn, c2_sn, SNname));(* 2 *)
      in(dsch, (RAND_sn: bitstring, CONC_sn: bitstring, AMF_sn: bitstring, MAC_sn: bitstring, HXRES'_sn: bitstring, c1: bitstring, c2:pubKey, hAT_MAC: bitstring, hAT_ENCR: bitstring));(*3*)
      out(usch, (RAND_sn, CONC_sn, AMF_sn, MAC_sn, c1, c2, hAT_MAC, hAT_ENCR));(* 4 *)
      in(usch, (RES'_sn: bitstring, uAT_MAC: bitstring));(* 5 *)
      if sha256((RAND_sn, RES'_sn)) = HXRES'_sn then
      (
         event middleSN_RES(RES'_sn, RAND_sn);
         out(dsch, (RES'_sn, uAT_MAC));(* 6 *)
         in(dsch, (SUPI_sn: bitstring, kSEAF_sn: key));(* 7 *)
         event endSN_ANCHOR_KEY(SUPI_sn, kSEAF_sn);
         in(usch, (urid: bitstring, uSNname: bitstring));(* 1- ERP *)
         out(dsch, (urid, SNname));(* 2- ERP *)
         in(dsch, (rMSK: key, AT_nonce: bitstring));(* 3- ERP *)
         out(usch, AT_nonce)(* 4- ERP *) 
      ).

   (* The process at the HN -------------------------------------------------------------- *)
   let HN(ueSUPI: bitstring, skHN: secKey)=
      in(sch, (dsch: channel));
      in(dsch, (c0_hn: pubKey, c1_hn: bitstring, c2_hn: bitstring, SNname_hn: bitstring));(*2- 4개*)
      new hRand: bitstring; (* 5G-AKA RAND 임의로 생성된 128비트 값 *)
      let (k1: key, k2: key) = get_hn_keys4supi(skHN, c0_hn, c1_hn, c2_hn) in
      if c2_hn = hmac(k2, c1_hn) then (* suci mac verification*)
      (
         let hSUPI = sdec(c1_hn, k1) in (* gettting SUPI *)
         (
            if ueSUPI = hSUPI then
            (
               
               event endUE_HN_SUPI(hSUPI, c0_hn, pk(skHN));
               get ueDB(=hSUPI, ueK, sqn) in 
               (
                  let hSQN = calc_sqn(sqn, c0_hn, hRand) in 
                  let (CONC: bitstring, AK: bitstring, hMAC: bitstring) = calc_hn_mac(hRand, ueK, hSQN, AMF) in                 
                  
                  let (RES:bitstring, kENCR: key, kAUT: key, XRES': bitstring, HXRES': bitstring, IK': bitstring, CK':bitstring, hAT_MAC: bitstring) = calc_AV(hMAC, AMF, hRand, ueK, hSQN, AK) in
                  (
                     new rID: bitstring;
                     let hAT_ENCR = xor(rID, k2b(kENCR)) in
                     let pkue1 = fP_pk1(c0_hn) in
                     let pkue2 = fP_pk2(c0_hn) in
                     let (ss: bitstring, c1: bitstring, c2:pubKey) = XWingKeyEnc(pkue1, pkue2) in
                     out(usch, test1);
                     event beginHN_UE_MAC(hSUPI, ueK, hRand, hSQN);     
                     out(dsch, (hRand, CONC, AMF, hMAC, HXRES', c1, c2, hAT_MAC, hAT_ENCR));(*3- 9개*)
                     in(dsch, (RES_hn: bitstring, uAT_MAC: bitstring));(*6- 4개*)
                     if RES_hn = XRES' then
                     (
                        if uAT_MAC = hmac(kAUT, (hRand, hSQN, AMF, hMAC, RES)) then
                        (
                            let MK_HYBRID  = k2b(KDF((ss))) in
                            let kRE = KDF_re((MK_HYBRID)) in
                            let kAUSF     = KDF((MK_HYBRID)) in
                            let kSEAF     = KDF((kAUSF, SNname)) in
                            event middleHN_RES(hSUPI, ueK, hRand, hSQN);
                            out(dsch, (hSUPI, kSEAF));(* 7 *)
                            in(dsch, (urID: bitstring, uSNname: bitstring));(* 2- ERP *)
                            if urID = rID then
                            ( 
                              new nonce_s: bitstring;
                              let rMK = KDF((kRE, rID, counter, nonce_s)) in
                              out(dsch, (rMK, xor(nonce_s, AK)))(* 3- ERP *)
                            )
                        )
                     )
                  )
               )
            )   
         )      
      ).      

   (* – Main Process – *)
   process      
      new prHN: secKey; let puHN = pk(prHN) in out(usch, puHN); 
      new SUPI: bitstring; new K: key;  
      new SQN: seq;
      
      insert ueDB(SUPI, K, SQN);
      (!UE(SUPI, K, SQN, puHN))|
      (!SN(SNname))|
      (!HN(SUPI, prHN))|
      phase 1; out(usch, (prHN, K))
